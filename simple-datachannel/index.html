<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Simple WebRTC DataChannel Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: sans-serif; background: #fff; color: #222; margin: 0; padding: 2em; }
    .row { margin-bottom: 1em; }
    label { margin-right: 0.5em; }
    input[type="text"] { width: 200px; }
    #log { background: #f3f3f3; border: 1px solid #ccc; height: 180px; overflow-y: auto; padding: 0.5em; font-family: monospace; margin-bottom: 1em; }
    .tx { color: #2563eb; }
    .rx { color: #059669; }
    .error { color: #dc2626; }
    button { margin-right: 0.5em; }
  </style>
</head>
<body>
  <div style="max-width: 600px; margin: 0 auto;">
    <a href="https://github.com/turnwebrtc/samples/tree/main/simple-datachannel" target="_blank">
      view source on GitHub
    </a>
    <h2>Simple WebRTC DataChannel Demo</h2>
    <p>
      This page lets you quickly try a peer-to-peer or TURN-relayed WebRTC data channel.
      Use the default <code>demo-api-key</code> or get your own API key at
      <a href="https://turnwebrtc.com/api-docs" target="_blank">turnwebrtc.com</a>
      for private rooms and production use.
    </p>
    <p>
      Open this page on two devices and join the same room to test.
    </p>
    <br />
    <div class="row">
      <label>API Key:</label>
      <input type="text" id="apiKey" placeholder="demo-api-key" value="demo-api-key">
    </div>
    <div class="row">
      <label>Room:</label>
      <input type="text" id="room" placeholder="room" value="asdf">
    </div>
    <div class="row" style="display: none;">
      <label><input type="checkbox" id="relayOnly">Relay only</label>
    </div>
    <div class="row">
      <button id="connectBtn">Connect</button>
      <button id="reloadBtn">Reload</button>
    </div>
    <div id="log"></div>
    <div class="row">
      <input type="text" id="msg" placeholder="Type message..." autocomplete="off">
      <button id="sendBtn" disabled>Send</button>
    </div>
  </div>
  <script>
    // --- Minimal signaling and datachannel logic ---
    let pc, dc, ws;
    const logDiv = document.getElementById('log');
    const connectBtn = document.getElementById('connectBtn');
    const reloadBtn = document.getElementById('reloadBtn');
    const sendBtn = document.getElementById('sendBtn');
    const apiKeyInput = document.getElementById('apiKey');
    const roomInput = document.getElementById('room');
    const msgInput = document.getElementById('msg');
    const relayOnlyInput = document.getElementById('relayOnly');
    msgInput.value = "turnwebrtc" + Math.floor(Math.random() * 999 + 1);
    let pendingCandidates = [];

    // Hide reload button initially
    reloadBtn.style.display = "none";

    function log(msg, cls) {
      console.log(cls, msg);
      const div = document.createElement('div');
      if (cls) div.className = cls;
      div.textContent = msg;
      logDiv.appendChild(div);
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    function setUI(connected) {
      // Hide connect button after first connect
      if (connected) {
        connectBtn.style.display = "none";
        reloadBtn.style.display = "";
        relayOnlyInput.disabled = true;
      }
      apiKeyInput.disabled = connected;
      roomInput.disabled = connected;
    }

    connectBtn.onclick = async () => {
      const apiKey = apiKeyInput.value.trim();
      const room = roomInput.value.trim();
      if (!apiKey || !room) {
        alert("Enter API key and room");
        return;
      }
      setUI(true);
      logDiv.innerHTML = "";
      // Connect signaling
      ws = new WebSocket(
        "wss://turnwebrtc.com/api/relay/" +
        encodeURIComponent(room) +
        "?apikey=" + encodeURIComponent(apiKey)
      );
      ws.onclose = () => log("[ws disconnected]", "tx");
      ws.onmessage = async (event) => {
        const msg = JSON.parse(event.data);
        console.log("msg", msg);
        if (msg.role === "o") {
          await createPeer(true);
          const offer = await pc.createOffer();
          log(`[created offer: ${offer.sdp}]`, "tx");
          await pc.setLocalDescription(offer);
          ws.send(JSON.stringify({ type: "offer", sdp: offer.sdp }));
          return;
        }
        switch (msg.type) {
          case "offer":
            log(`[received offer: ${msg.sdp}]`, "rx");
            await createPeer(false);
            try {
              // Set remote description and wait for completion
              await pc.setRemoteDescription({ type: "offer", sdp: msg.sdp });
            } catch (e) {
              log(`[error setting remote description: ${e.message}]`, "error");
              break;
            }

            let answer;
            try {
              answer = await pc.createAnswer();
            } catch (e) {
              log(`[error creating answer: ${e.message}]`, "error");
              break;
            }
            log(`[created answer: ${answer.sdp}]`, "tx");

            try {
              ws.send(JSON.stringify({ type: "answer", sdp: answer.sdp }));
            } catch (e) {
              log(`[error sending answer: ${e.message}]`, "error");
              break;
            }

            try {
              await pc.setLocalDescription(answer);
            } catch (e) {
              log(`[error setting local description: ${e.message}]`, "error");
            }

            try {
              // Only process candidates if remote description is set
              if (pc.remoteDescription) {
                for (const c of pendingCandidates) {
                  try {
                    await pc.addIceCandidate(c);
                  } catch (e) {
                    log(`[error adding ICE candidate: ${e.message}]`, "error");
                  }
                }
                pendingCandidates = []; // Clear after processing
              } else {
                log("[warning: remote description not set, queuing candidates]", "tx");
              }
            } catch (e) {
              log(`[error processing ICE candidates: ${e.message}]`, "tx");
            }
            break;
          case "answer":
            try {
              log(`[received answer: ${msg.sdp}]`, "rx");
              await pc.setRemoteDescription({ type: "answer", sdp: msg.sdp });
            } catch (e) {
              log(`[error processing answer: ${e.message}]`, "error");
            }
            break;
          case "candidate":
            if (msg.candidate) {
              const cand = new RTCIceCandidate(msg);
              if (pc && pc.remoteDescription) {
                try {
                  await pc.addIceCandidate(cand);
                  log(`[added ICE candidate: ${cand.candidate}]`, "rx");
                } catch (e) {
                  log(`[error adding ICE candidate: ${e.message}]`, "error");
                }
              } else {
                pendingCandidates.push(cand);
                log(`[queued ICE candidate ${cand.candidate}]`, "rx");
              }
            }
            break;
          case "bye":
            disconnect();
            break;
          default:
            log(`[unknown message type: ${msg.type}]`, "rx");
            break;
        }
      };
    };

    reloadBtn.onclick = () => {
      window.location.reload();
    };

    function disconnect() {
      if (dc) { dc.close(); dc = null; }
      if (pc) { pc.close(); pc = null; }
      if (ws) { ws.close(); ws = null; }
      // Don't call setUI(false), just log and leave UI as is
      log("[disconnected]", "tx");
    }

    async function createPeer(isOfferer) {
      if (pc) pc.close();
      const rtcConfig = {
        iceServers: await fetchTurn(),
      };
      if (relayOnlyInput.checked) {
        rtcConfig.iceTransportPolicy = "relay";
      }
      log(`[ice servers: ${JSON.stringify(rtcConfig.iceServers)}]`, "tx");
      pc = new RTCPeerConnection(rtcConfig);
      pc.onicecandidate = (e) => {
        if (e.candidate && ws && ws.readyState === 1) {
          log(`[sending ICE candidate: ${e.candidate.candidate}]`, "tx");
          ws.send(JSON.stringify({
            type: "candidate",
            candidate: e.candidate.candidate,
            sdpMid: e.candidate.sdpMid,
            sdpMLineIndex: e.candidate.sdpMLineIndex
          }));
        }
      };
      if (isOfferer) {
        dc = pc.createDataChannel("chat");
        setupDC();
      } else {
        pc.ondatachannel = (e) => {
          dc = e.channel;
          setupDC();
        };
      }
      pc.onconnectionstatechange = () => {
        log(`[connection state: ${pc.connectionState}]`, "tx");
        if (pc.connectionState === "connected") {
          // Close signaling WebSocket once WebRTC is up
          if (ws && ws.readyState === 1) {
            ws.close();
            ws = null;
          }
        }
        if (["disconnected", "failed", "closed"].includes(pc.connectionState)) {
          disconnect();
        }
      };
    }

    function setupDC() {
      dc.onopen = () => {
        log("[datachannel open]", "rx");
        sendBtn.disabled = false;
      };
      dc.onclose = () => {
        log("[datachannel closed]", "tx");
        sendBtn.disabled = true;
      };
      dc.onmessage = (e) => {
        log("> " + e.data, "rx");
      };
    }

    sendBtn.onclick = () => {
      if (dc && dc.readyState === "open") {
        const msg = msgInput.value;
        if (msg) {
          dc.send(msg);
          log("< " + msg, "tx");
          // Do not clear msgInput.value
        }
      }
    };

    async function fetchTurn() {
      try {
        const apiKey = apiKeyInput.value.trim();
        const resp = await fetch("https://turnwebrtc.com/api/credentials", {
          headers: { Authorization: "Basic " + btoa(apiKey + ":") }
        });
        if (!resp.ok) throw new Error("cred fetch failed");
        return await resp.json();
      } catch {
        return [{ urls: ["stun:stun.l.google.com:19302"] }];
      }
    }
  </script>
</body>
</html>
